<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Apple Disk Controller ROM | CARC</title>
    
    
      <meta name="description" content="Corpus Analysis of Retro Code">
    
    
    <link rel="stylesheet" href="/CARC/style.css?1c9f7987accc6b28287cb484a4912c8c">
    <link rel="alternate" type="application/atom+xml" href="https://jtauber.github.io/CARC/atom.xml">
  </head>
  <body class="base">
    <aside>
      <hgroup>
  <h1><a href="/CARC/">CARC</a></h1>
  <div class="site-description"><b>C</b>orpus <b>A</b>nalysis of <b>R</b>etro <b>C</b>ode</div>
</hgroup>

<nav>
  <a target="_blank" href="https://github.com/jtauber/CARC">GitHub Repo</a>

</nav>

<p>
  While there has been digital humanities work on old code, I’m not aware of
  any straight up application of corpus linguistic approaches to its study.
</p>

<p>
  The idea for this project came about when I read a discussion of whether
  <code>LDA</code> was the most common 6502 instruction and it occurred to me that this,
  along with a lot of subtleties, is a very “corpus linguistics” question to
  ask.
</p>

<p>
  The acronym is a Tolkien reference, “Carc” being a legendary raven from the
  past in <cite>The Hobbit</cite>.
</p>

<p class="feed">
  <a href="/CARC/atom.xml">
    <svg class="svg-icon">
      <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
        11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
        13.806c0-1.21.983-2.195 2.194-2.195zM10.606
        16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
      />
    </svg>
    Atom Feed
  </a>
</p>
    </aside>
    <main>
      
  <h1>Apple Disk Controller ROM</h1>

  <p>The disk hardware is controlled through 16 latched toggles mapped to
addresses <code>$C0<var>Z</var>0</code> through <code>$C0<var>Z</var>F</code>
where <code><var>Z</var></code> is the slot number + 8.</p>
<p>This is achieved using an index addressing mode with <code>SLOT16</code> (16 times the
slot number) in <code>X</code>: e.g. <code>LDA $C089,X</code>.</p>
<p>The first eight of these turn off or on different stepper phases. </p>
<table class="table">
  <tr><td><code>$C0<var>Z</var>0</code></td><td>Phase 0 OFF</td></tr>
  <tr><td><code>$C0<var>Z</var>1</code></td><td>Phase 0 ON</td></tr>
  <tr><td><code>$C0<var>Z</var>2</code></td><td>Phase 1 OFF</td></tr>
  <tr><td><code>$C0<var>Z</var>3</code></td><td>Phase 1 ON</td></tr>
  <tr><td><code>$C0<var>Z</var>4</code></td><td>Phase 2 OFF</td></tr>
  <tr><td><code>$C0<var>Z</var>5</code></td><td>Phase 2 ON</td></tr>
  <tr><td><code>$C0<var>Z</var>6</code></td><td>Phase 3 OFF</td></tr>
  <tr><td><code>$C0<var>Z</var>7</code></td><td>Phase 3 ON</td></tr>
</table>

<p>To move the head inward, the phases are turned on and off in ascending order
at a particular timing. To move the head outward, the same is done in
descending order.</p>
<p>There are 70 positions the head can take but data written from adjacent
positions can interfere with each other and so the usable positions must be
separated. In practice, Apple DOS used the even positions (although one
copy-protection tactic was to use odd positions or some other pattern
that avoided adjacent positions).</p>
<p>The next eight toggles were as follows:</p>
<table class="table">
  <tr><td><code>$C0<var>Z</var>8</code></td><td>Motor OFF</td></tr>
  <tr><td><code>$C0<var>Z</var>9</code></td><td>Motor ON</td></tr>
  <tr><td><code>$C0<var>Z</var>A</code></td><td>Select Drive 1</td></tr>
  <tr><td><code>$C0<var>Z</var>B</code></td><td>Select Drive 2</td></tr>
  <tr><td><code>$C0<var>Z</var>C</code></td><td>Strobe Data Latch</td></tr>
  <tr><td><code>$C0<var>Z</var>D</code></td><td>Load Data Latch</td></tr>
  <tr><td><code>$C0<var>Z</var>E</code></td><td>Ready Latch for Read</td></tr>
  <tr><td><code>$C0<var>Z</var>F</code></td><td>Ready Latch for Write</td></tr>
</table>

<p>We will cover these in more detail as we encounter them.</p>
<h2>Seeking Track Zero</h2>
<p>Rather than precisely move the head to track zero on boot, the disk controller
just moves the head out by 80 positions. This guarantees it is in the outermost
position regardless of its starting point. This is also what causes the
distinctive thunk-thunk-thunk sound on disk boot as the head repeatedly hits a
rubber stopper designed to prevent it moving too far.</p>
<p>At this point in the code, we’ve just calculated <code>SLOT16</code> and it is still in
the accumulator. We transfer it to <code>X</code>:</p>
<pre class="codehilite"><code>Cs2E: AA            TAX
</code></pre>

<p>We ready the latch for reading and strobe it.</p>
<pre class="codehilite"><code>Cs2F: BD 8E C0      LDA $C08E,X
Cs32: BD 8C C0      LDA $C08C,X
</code></pre>

<p>Then we select drive 1 and spin up the motor.</p>
<pre class="codehilite"><code>Cs35: BD 8A C0      LDA $C08A,X
Cs38: BD 89 C0      LDA $C089,X
</code></pre>

<p>We want to loop 80 times, so we put that in <code>Y</code>:</p>
<pre class="codehilite"><code>Cs3B: A0 50         LDY #80
</code></pre>

<p>We turn off the Phase 0 stepper motor. Remember that initially <code>X</code> is <code>SLOT16</code>.</p>
<pre class="codehilite"><code>Cs3D: BD 80 C0      LDA $C080,X
</code></pre>

<p>Note that on subsequent steps of the loop, <code>X</code> will be <code>SLOT16</code> plus 2 × PHASE.
We’re now at the part of the code that will calculate this.</p>
<p>We take the loop index (in <code>Y</code>) modulo 4 (to get the phase) and
double it (to get the low four bits of the address to toggle).</p>
<pre class="codehilite"><code>Cs40: 98            TYA
Cs41: 29 03         AND #$03
Cs43: 0A            ASL
</code></pre>

<p>When <code>Y</code> is <code>80</code>, we get <code>0</code>; when <code>Y</code> is <code>79</code>, we get <code>6</code>; when <code>Y</code> is <code>78</code>,
we get <code>4</code>; then <code>2</code>; then back to <code>0</code> and so on. In other words, 2 × PHASE.
And because <code>Y</code> is decrementing, we are cycling through the phases in descending
order which means the head will move outwards.</p>
<p><code>SLOT16</code> is also in zero-page <code>$2B</code> so lets combine that with the 2 × PHASE.</p>
<pre class="codehilite"><code>Cs44: 05 2B         ORA $2B
Cs46: AA            TAX
</code></pre>

<p>Now <code>X</code> is <code>SLOT16</code> + 2 × PHASE, which is exactly what we need to turn on
that stepper motor phase.</p>
<pre class="codehilite"><code>Cs47: BD 81 C0      LDA $C081,X
</code></pre>

<p>Now the timing is important. We need to wait about 20 milliseconds. There is
a <code>MON_WAIT</code> routine in the monitor (<code>$FCA8</code>) that consumes cycles as a quadratic
function of the accumulator (the number of cycles is 2.5<code>A</code>² + 13.5<code>A</code> + 7).</p>
<p>We set <code>A</code> to <code>#$56</code> and call <code>MON_WAIT</code> which will consume a total of 19,664
cycles including the <code>JSR</code>.</p>
<pre class="codehilite"><code>Cs4A: A9 56         LDA #$56
Cs4C: 20 A8 FC      JSR MON_WAIT
</code></pre>

<p>We now decrement the index and loop.</p>
<pre class="codehilite"><code>Cs4F: 88            DEY
Cs50: 10 EB         BPL $Cs3D
</code></pre>

<p>Once we’ve moved the head out, we set up some more zero-page values.</p>
<p>Note that <code>A</code> is now <code>#$00</code> because that’s what it ends up as after a <code>MON_WAIT</code>.</p>
<pre class="codehilite"><code>Cs52: 85 26         STA $26
Cs54: 85 3D         STA $3D
Cs56: 85 41         STA $41
Cs58: A9 08         LDA #$08
Cs5A: 85 27         STA $27
</code></pre>

<p>So this puts <code>#$0800</code> into <code>$26</code>/<code>$27</code> (the location of the data better to load
the first sector into) and <code>#$00</code> into <code>$3D</code> (the sector to load) and <code>$41</code> (the
track to load).</p>
<h2>Looking for Headers</h2>
<p>With our drive head on the outermost track, we’re now going to read bytes until
we see what’s known as the <strong>address header</strong>. We’ll then check we’ve got track
0 and sector 0 and, then look for the <strong>data header</strong> and load in the data.</p>
<p>Whether we’re looking for the address header or the subsequent data header is
captured in the carry flag.</p>
<p>Because we want to find the address header first, we clear the carry and store
the flags on the stack.</p>
<pre class="codehilite"><code>Cs5C: 18            CLC
Cs5D: 08            PHP
</code></pre>

<p>Next we strobe the latch until the high bit is on (which indicates data has
been read).</p>
<pre class="codehilite"><code>Cs5E: BD 8C C0      LDA $C08C,X
Cs61: 10 FB         BPL $Cs5E
</code></pre>

<p>Then we test whether it is <code>#$D5</code> and, if not, loop back and read again.</p>
<pre class="codehilite"><code>Cs63: 49 D5         EOR #$D5
Cs65: D0 F7         BNE $Cs5E
</code></pre>

<p>It is important to note that the actual bytes read off disk into the latch
are not the actual bytes we’re ultimately going to load into memory. The data
is encoded to get around certain physical limitations in the hardware. We’ll
shortly get into two types of encoding used.</p>
<p>Both the address header and data header start with <code>$D5</code> so that’s what we
initially look for. It is not actually possible to get a <code>$D5</code> in either of
the encodings used and so a <code>$D5</code> can only mean the start of a header.</p>
<p>The next byte, whether an address header or data header, is always <code>$AA</code>.</p>
<p>We loop until we get the high bit set on the latch.</p>
<pre class="codehilite"><code>Cs67: BD 8C C0      LDA $C08C,X
Cs6A: 10 FB         BPL $Cs67
</code></pre>

<p>Then we compare what we get with <code>#$AA</code>. Notice this time we use <code>CMP</code> not <code>EOR</code>.
That is because we want to keep the value in <code>A</code> (<code>EOR</code> is destructive).
If we didn’t get an <code>$AA</code> we jump back to see if we actually got another <code>$D5</code>.</p>
<pre class="codehilite"><code>Cs6C: C9 AA         CMP #$AA
Cs6E: D0 F3         BNE $Cs63
Cs70: EA            NOP
</code></pre>

<p>If we did get an <code>$AA</code>, we continue. It’s not clear why there is an <code>NOP</code> here.</p>
<p>We read the third byte</p>
<pre class="codehilite"><code>Cs71: BD 8C C0      LDA $C08C,X
Cs74: 10 FB         BPL $C6s71
</code></pre>

<p>and compare it to <code>#$96</code>.</p>
<pre class="codehilite"><code>Cs76: C9 96         CMP #$96
Cs78: F0 09         BEQ $Cs83
</code></pre>

<p>If so, we have an address header <code>D5 AA 96</code> and jump to <code>$Cs83</code> to handle it.</p>
<p>Note that we do this <em>even if we were looking for a data header</em> because it
means we’ve hit a new sector and need to check if it’s the right one.</p>
<p>But if we got a <code>D5 AA</code> that isn’t followed by a <code>96</code>, what we do next does
depend on whether we’re looking for data and so we pull the status and if we
were actually looking for an address header (i.e. the carry flag is clear),
we'll start the whole process again.</p>
<pre class="codehilite"><code>Cs7A: 28            PLP
Cs7B: 90 DF         BCC $Cs5C
</code></pre>

<p>But if we are looking for data, we check if we got a <code>#$AD</code> (because a data
header starts with <code>D5 AA AD</code>). If so, we branch to <code>$CsA6</code> to handle the data.
Otherwise we go back and keep looking.</p>
<pre class="codehilite"><code>Cs7D: 49 AD         EOR #$AD
Cs7F: F0 25         BEQ $CsA6
Cs81: D0 D9         BNE $Cs5C
</code></pre>

<p>It is worth noting here what each of <code>D5</code>, <code>AA</code>, <code>96</code>, and <code>AD</code> look like in
binary:</p>
<table class="table">
  <tr><td><code>D5</code></td><td><code>11010101</code></td></tr>
  <tr><td><code>AA</code></td><td><code>10101010</code></td></tr>
  <tr><td><code>96</code></td><td><code>10010110</code></td></tr>
  <tr><td><code>AD</code></td><td><code>10101101</code></td></tr>
</table>

<p>TO BE CONTINUED</p>

    </main>
  </body>
</html>